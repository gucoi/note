在 Rust 中，闭包（closures）是一种可以捕获其创建环境中的变量的匿名函数。它们允许你定义一个临时的一次性函数，可以在任何地方使用，并且能够访问外部作用域内的数据。闭包有三种捕获机制，它们对应于三个不同的 Fn 属性：`Fn`, `FnMut`, 和 `FnOnce`。

## 1. `Fn`

`Fn` 是一种不会修改捕获值的闭包类型。它接收对捕获值的不可变引用，因此不允许修改这些值。如果闭包不修改任何捕获的变量，那么它可以实现 `Fn` trait。

```rust
let x = 5;
let add_x = |y| y + x; // 不可变借用

assert_eq!(add_x(3), 8);
```

## 2. `FnMut`

`FnMut` 是一种可能修改捕获值的闭包类型。它接收对捕获值的可变引用，因此允许修改这些值。如果闭包修改了任何捕获的变量，那么它可以实现 `FnMut` trait。

```rust
let mut x = 5;
let mut_inc = || {
    x += 1;
    x
};

assert_eq!(mut_inc(), 6);
```

## 3. `FnOnce`

`FnOnce` 是一种只能被调用一次的闭包类型。它通过移动捕获的值来获取所有权，而不是借用。这意味着闭包一旦被执行，它的捕获值就不再可用，因为所有权已经转移给了闭包。当闭包返回时，所有被捕获的值都会被清理。如果闭包需要获取捕获值的所有权，那么它可以实现 `FnOnce` trait。

```rust
let x = String::from("Hello");
let take_x = || {
    println!("Taking ownership of {}", x);
    std::mem::drop(x); // 执行后，x 的内存将被释放
};
take_x();
// 这里不能再使用 x，因为它已经被移动给闭包并清理掉了
```

注意，即使闭包实现了 `FnOnce`，也并不意味着它不能同时实现 `Fn` 或 `FnMut`。Rust 编译器会自动选择最合适的闭包类型。例如，如果你有一个只读的闭包，它仍然可以作为 `FnMut` 使用，因为它不需要修改捕获的值。

闭包的捕获机制是由编译器根据闭包体内部使用的变量决定的。这使得 Rust 能够在编译时确保正确地管理内存和所有权规则，避免悬垂指针和其他潜在的问题。