## 工作原理

Libpcap的工作原理可以描述为，当一个数据包到达网卡时，通过网络分接口（即旁路机制）将数据包发给BPF过滤器，匹配通过的数据包可以被libpcap利用创建的套接字**PF_PACKET**从链路层驱动程序中获得。进而在用户空间提供独立于系统的用户级API接口。

![[Pasted image 20240918095054.png]]

一个数据包的捕捉分为三个主要部分
* 面向底层包捕获
* 面向中间层数据包捕获
* 面向应用层的用户捕获

## 实现机制

在数据链路层增加旁路处理，不干扰自身的网络协议栈的处理，对发送和接收的数据包通过 Linux 内核做过滤和缓冲处理，最后直接传递给上层的应用。

![[Pasted image 20240918095735.png]]

1. 数据包到达网卡设备。
2. 网卡设备依据配置进行DMA操作。（第1次拷贝：网卡寄存器->内核为网卡分配的缓冲区ring buffer）
3. 网卡发送中断，唤醒处理器。
4. 驱动软件从ring buffer中读取，填充内核skbuff结构（第2次拷贝：内核网卡缓冲区ring buffer->内核专用数据结构skbuff）
5. 接着调用netif_receive_skb函数：如果有抓包程序，由网络分接口进入BPF过滤器，将规则匹配的报文拷贝到系统内核缓存 （第3次拷贝）。BPF为每一个要求服务的抓包程序关联一个filter和两个buffer。BPF分配buffer 且通常情况下它的额度是4KB the store buffer 被使用来接收来自适配器的数据； the hold buffer被使用来拷贝包到应用程序。
6. 处理数据链路层的桥接功能；根据skb->protocol字段确定上层协议并提交给网络层处理，进入网络协议栈，进行高层处理。libpcap绕过了Linux内核收包流程中协议栈部分的处理，使得用户空间API可以直接调用套接字PF_PACKET从链路层驱动程序中获得数据报文的拷贝，将其从内核缓冲区拷贝至用户空间缓冲区（第4次拷贝）
### PF_PACKET


### mmap

libpcap-mmap是对旧的libpcap实现的改进，新版本的libpcap基本都采用packet_mmap机制[[#PACKET_MMAP]]。PACKET_MMAP通过mmap，减少一次内存拷贝（第4次拷贝没有了），减少了频繁的系统调用，大大提高了报文捕获的效率。

###
 